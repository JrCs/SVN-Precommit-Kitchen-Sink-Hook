#! /usr/bin/env perl
# pre-commit-kitchen-sink-hook
########################################################################

use strict;
use warnings;
use feature qw(say);

use Data::Dumper;
use Getopt::Long;
use Pod::Usage;

use constant {
    SVNLOOK_DEFAULT	=> '/usr/bin/svnlook',
    SVN_REPO_DEFAULT	=> '/path/to/repository',
    SECTION_HEADER	=> qr/^\s*\[\s*(\w+)\s+(.*)\]\s*$/,
    PARAMETER_LINE	=> qr/^\s*(\w+)\s*=\s*(.*)$/,
};

use constant { 		#Control File Type (package Control)
    FILE_IN_REPO	=> "R",
    FILE_ON_SERVER	=> "F",
};

use constant {		#Revision file Type (package Configuration)
    TRANSACTION 	=> "T",
    REVISION		=> "R",
};
$| = 1;

########################################################################
# GET OPTION
#
my $svnlook			= SVNLOOK_DEFAULT;
my $control_file_on_server	= SVN_REPO_DEFAULT;

my @control_files_in_repo;	#Control File location inside Repository
my $transaction;		#Transaction ID (Used by hook)
my $revision;			#Subversion Revision Number (Used for testing)
my $parse_only;			#Only parse the control file
my $want_help;			#User needs help with options
my $show_perldoc;		#Show the entire Perl documentation

my $error_message;		#Error Message to display

GetOptions (
    'svnlook=s'			=> \$svnlook,
    'file=s'			=> \$control_file_on_server,
    'filelocation=s'		=> \@control_files_in_repo,
    't=s'			=> \$transaction,
    'r=i'			=> \$revision,
    'parse'			=> \$parse_only,
    'help'			=> \$want_help,
    'documentation'		=> \$show_perldoc,
) or $error_message = 'Invalid options';

my $svn_repository = shift;

if ( not defined $svn_repository ) {
    $error_message .= "\nNeed to pass the repository name";
}

if ( not ( defined $revision or defined $transaction ) ) {
    $error_message .= "\nNeed to specify either a transaction or Subversion revision";
}

if ( defined $revision and defined $transaction ) {
    $error_message .= "\nOnly define either revision or transaction";
}

if ( not ( defined $control_file_on_server or @control_files_in_repo ) ) {
    $error_message .= "\nNeed to specify a control file";
}

if ( $show_perldoc ) {
    pod2usage ( -exitstatus => 0, -verbose => 2 );
}

if ( $want_help ) {
    pod2usage ( -verbose => 0, -exitstatus => 0 );
}

if ( defined $error_message ) {
    pod2usage ( -message => $error_message, -verbose => 0, -exitstatus => 2 );
}

#
########################################################################

########################################################################
# SETUP CONFIGURATION INFORMATION
#

my $configuration = Configuration->new;

$configuration->Repository($svn_repository);
$configuration->Svnlook($svnlook);

my $rev_param = defined $revision ? "-r$revision" : "-t$transaction";
$configuration->Rev_param($rev_param);

my $author;
eval {
    $author = qx( $svnlook author $rev_param  "$svn_repository" );
};
chomp $author;

if ( not $parse_only and not defined $author ) {
    die qq(Author of change cannot be found\n);
}
$configuration->Author($author);

#
# Save Control File on server
#

my @control_file_list;
if ( defined $control_file_on_server ) {
    push @control_file_list, Control_file->new( FILE_ON_SERVER, $control_file_on_server );
}

#
# Save Control Files stored in Repository;
#

for my $control_file ( @control_files_in_repo ) {
    push @control_file_list,
	Control_file->new(FILE_IN_REPO, $control_file, $configuration);
}
#
########################################################################

########################################################################
# BUILD CONTROL FILE SECTIONS
#

#
# This is a hash of each type of section. Each entry in this hash is
# an array of these types
#

my $sections = Section_group->new;
my $errors = Error->new;
for my $control_file ( @control_file_list ) {
    my $section;
    my @control_file_lines = $control_file->Content;
    for my $line_number ( (0..$#control_file_lines) ) {
	my $line = $control_file_lines[$line_number];
	next unless $line;	#Ignore blank lines
	if ( $line =~ SECTION_HEADER ) {
	    my $section_type = $1;
	    my $description = $2;
	    #
	    # For Error Purposes
	    #
	    $section->Control_file_line = $line_number;
	    $section->Control_file = $control_file;
	    eval { $section = Section->new( $section_type, $description ); };
	    if ( $@ ) {
		my $error = qq(Invalid Section Type "$section_type");
		$parse_error->Error($error, $control_file, $line_number);
	    }
	    $sections->Add($section);
	}
	elsif ( $line =~ PARAMETER_LINE ) {
	    my $parameter = $1;
	    my $value	= $2;
	    eval { $section->Parameter( $parameter, $value ); };
	    if ($@) {
		my $error = qq(Invalid Parameter "$parameter");
		$parse_error->Error($error, $control_file, $line_number);
	    }
	}
	else { #Invalid Line
	    my $error = qq(Invalid Line in "$line")
	    $parse_error->Error($error, $control_file, $line_number);
	}
    }
}

#
# Verify Required Parameters were given
#
for my $section_type ( keys %section_types ) {
    for my $section ( @{ $section_types{$section_type} } ) {
	eval { $section->Verify_parameters; } ;
	if ($@) {
	    my $error = "Missing required parameter\n"
		. qq( Control file: ) . $section->Control_file_name 
		. qq( Line: ) . $section->Control_file_line
		. qq(\n\t[) . $section->Control_file_type . " "
		. $section->Description . "]";
	    push @errors, $error;
	}
    }
}

#
# Check for Errors
#
if ( @errors ) {
    for my $error ( @errors ) {
	print STDERR "$error\n";
    }
}

say Dumper \%section_types;
say "-" x 72;
say Dumper $configuration;

#
########################################################################

########################################################################
# PACKAGE Configuration
#
# Description
# Stores the configuration information for the transaction. This
# includes the initial parameters, the control files, the sections,
# the user, etc.
#    
package Configuration;
use Carp;

sub new {
    my $class		= shift;

    my $self = {};
    bless $self, $class;
    return $self;
}

sub Author {
    my $self		= shift;
    my $author		= shift;

    if ( defined $author ) {
	$self->Ldap_user($author);	#Preserved with spaces and case;
	$author =~ s/\s+/_/g;		#Replace whitespace with underscores
	$self->{AUTHOR} = lc $author;
    }
    return $self->{AUTHOR};
}

sub Ldap_user {
    my $self		= shift;
    my $ldap_user	= shift;

    if ( defined $ldap_user ) {
	$self->{LDAP_USER} = $ldap_user;
    }
    return $self->{LDAP_USER};
}

sub Repository {
    my $self		= shift;
    my $repository	= shift;

    if ( defined $repository ) {
	$repository =~ s{\\}{/}g;	#Change from Windows to Unix file separators
	$self->{REPOSITORY} = $repository;
    }

    return $self->{REPOSITORY};
}

sub Rev_param {
    my $self		= shift;
    my $rev_param	= shift;

    if ( defined $rev_param and  $rev_param =~ /^-[tr]/ )  {
	$self->{REV_PARAM} = $rev_param;
    }
    elsif ( defined $rev_param and $rev_param !~ /^[tr]/ ) {
	croak qq(Revision parameter must start with "-t" or "-r");
    }
    return $self->{REV_PARAM};
}

sub Svnlook {
    my $self		= shift;
    my $svnlook		= shift;

    if ( defined $svnlook ) {
	if ( not -x $svnlook ) {
	    croak qq(The program "$svnlook" is not an executable program");
	}
	$self->{SVNLOOK} = $svnlook;
    }

    return $self->{SVNLOOK};
}

#
########################################################################

########################################################################
# PACKAGE Control_file
#
# Stores Location, Type, and Contents of the Control File
#
package Control_file;
use Data::Dumper;
use autodie;
use Carp;

use constant {
    FILE_IN_REPO	=> "R",
    FILE_ON_SERVER	=> "F",
};

sub new {
    my $class		= shift;
    my $type		= shift;
    my $location	= shift;
    my $configuration	= shift;	#Needed if file is in repository

    if ( not defined $type ) {
	croak qq/Must pass in control file type ("R" = in repository. "F" = File on Server")/;
    }
    if ( not defined $location ) {
	croak qq(Must pass in Control File's location);
    }

    if ( $type eq FILE_IN_REPO and not defined $configuration ) {
	croak qq(Need to pass a configuration when control file is in the repository);
	if ( not $configuration->isa( "Configuration" ) ) {
	    croak qq(Configuration parameter needs to be of a Class "Configuration");
	}
    }

    my $self = {};
    bless $self, $class;
    $self->Type($type);
    $self->Location($location);

    #
    # Get the contents of the file
    #

    if ( $type eq FILE_ON_SERVER ) {
	my $control_file_fh;
	eval { open $control_file_fh, "<", $location; };
	if ( $@ ) {
	    croak qq(Invalid Control file "$location" on server.);
	}
	my @file_contents = <$control_file_fh>;
	close $control_file_fh;
	chomp @file_contents;
	$self->Content(\@file_contents);
    }
    else {
	my $rev_param   = $configuration->Rev_param;
	my $svnlook     = $configuration->Svnlook;
	my $repository  = $configuration->Repository;
	my @file_contents;
	eval {
	    @file_contents = qx($svnlook cat $rev_param $repository $location);
	};
	if ($@) {
	    croak qq(Couldn't retreive contents of control file)
		. qq("$location" from repository "$repository");
	}
	$self->Content(\@file_contents);
    }
    return $self;
}

sub Location {
    my $self		= shift;
    my $location	= shift;

    if ( defined $location ) {
	$self->{LOCATION} = $location;
    }
    return $self->{LOCATION};
}

sub Type {
    my $self		= shift;
    my $type		= shift;

    if ( defined $type ) {
	if ( $type ne FILE_IN_REPO and $type ne FILE_ON_SERVER ) {
	    croak qq(Type must be either ") . FILE_IN_REPO
	    . qq(" or ") . FILE_ON_SERVER . qq(".);
	}
	$self->{TYPE} = $type;
    }
    return $self->{TYPE};
}

sub Content {
    my $self		= shift;
    my $contents_ref	= shift;

    if ( defined $contents_ref ) {
	my @contents;
	for my $line ( @{$contents_ref} ) {
	    $line =~ s/^\s*$//;		#Make blank lines empty
	    $line =~ s/^\s*[#;].*//;	#Make comment lines empty
	    push @contents, $line;
	}
	$self->{CONTENTS} = \@contents;
    }
    my @contents = @{ $self->{CONTENTS} };
    return wantarray ? @contents : \@contents;
}
#
########################################################################

########################################################################
# PACKAGE Section
#
# Various Section Objects. Each one is a different type and has
# have different attributes. Master is for general definition
#

package Section;
use Data::Dumper;
use Carp;

use constant {
    FILE_IN_REPO	=> "R",
    FILE_ON_SERVER	=> "F",
};

sub new {
    my $class		= shift;
    my $type		= shift;
    my $description	= shift;

    if ( not defined $type or not defined $description ) {
	croak qq(You must pass in the Section type and Description);
    }

    $type = ucfirst lc $type;	#In the form of a Sub-Class Name

    $class .= "::$type";

    my $self = {};
    bless $self, $class;

    if ( not $self->isa("Section") ) {
	croak qq(Invalid Section type "$type" in control file);
    }

    $self->Description($description);
    return $self;
}

sub Description {
    my $self		= shift;
    my $description	= shift;

    if ( defined $description ) {
	$self->{DESCRIPTION} = $description;
    }
    return $self->{DESCRIPTION};
}

sub Control_file {
    my $self		= shift;
    my $control_file 	= shift;

    if ( defined $control_file ) {
	if ( ref $control_file ne "Control_file" ) {
	    croak qq(Control file must be of a type "Control_file");
	}
	$self->{CONTROL_FILE_NAME} = $control_file;
    }
    return $self->{CONTROL_FILE_NAME};
}

sub Control_file_line {
    my $self		= shift;
    my $line_number	= shift;

    if ( defined $line_number ) {
	$self->{LINE_NUMBER} = $line_number;
    }
    return $self->{LINE_NUMBER};
}

sub Parameter {
    my $self		= shift;
    my $parameter	= shift;
    my $value		= shift;

    if ( not defined $parameter ) {
	croak qq(Missing parameter "parameter");
    }
    my $method = ucfirst lc $parameter;

    if ( not $self->can($method) ) {
	croak qq(Invalid parameter "$parameter" passed);
    }

    if ( defined $value ) {
	$self->$method($value);
    }
    return $self->$method;
}

sub Verify_parameters {
    my $self		= shift;
    my $req_method_ref	= shift;

    my @req_methods = $req_method_ref;
    say Dumper \@req_methods;

    #
    # Call the various methods
    #
    for my $method ( @req_methods ) {
	$method = ucfirst lc $method;
	if ( not $self->$method ) {
	    croak qq(Missing required parameter "$method");
	}
    }
    return 1;
}

sub glob2regex {
    my $glob = shift;

    # Due to collision when replacing "*" and "**", we use the NUL
    # character as a temporary replacement for "**" and then replace
    # "*". After this is done, we can replace NUL with ".*".

    $glob =~ s{\\}{/}g; 		#Change backslashes to forward slashes

    # Quote all regex characters
    ( my $regex = $glob ) =~ s{([\.\+\{\}\[\]])}{\\$1}g;

    # Replace double asterisks. Use \0 to mark place
    $regex =~ s{\*\*}{\0}g;

    # Replace single asterisks only
    $regex =~ s/\*/[^\/]*/g;

    # Replace ? with .
    $regex =~ s/\?/./g;

    # Replace \0 with ".*"
    $regex =~ s/\0/.*/g;

    return "^$regex\$";
}
#
# END: CLASS: Section
########################################################################

########################################################################
# CLASS: Section::Group
#
package Section::Group;
use base qw(Section);
use Carp;

use constant REQ_PARAMETERS	=> qw(Users);

sub Users {
    my $self		= shift;
    my $users		= shift;

    if ( defined $users ) {
	my @users = split /[\s,]+/, $users;
	$self->{USERS} = \@users;
    }

    my @users = @{ $self->{USERS} };
    return wantarray ? @users : \@users;
}
#

sub Verify_parameters {
    my $self =		shift;
    my $required =	\@{ +REQ_PARAMETERS };

    return $self->SUPER::Verify_parameters($required);
}
#
# END: CLASS: Section::Group
########################################################################

########################################################################
# CLASS: Section::File
#
package Section::File;
use base qw(Section);
use Carp;

use constant REQ_PARAMETERS 	=> qw(Match Users Access);
use constant VALID_CASES	=> qw(match ignore);
use constant VALID_ACCESSES	=> qw(read-only read-write add-only no-delete no-add);

sub Match {
    my $self		= shift;
    my $match		= shift;

    if ( defined $match ) {
	$self->{MATCH} = $match;
    }

    return $self->{MATCH};
}

sub Access {
    my $self		= shift;
    my $access		= shift;

    if ( defined $access ) {
	$access = lc $access;
	my %valid_accesses;
	map { $valid_accesses{lc $_} = 1 } +VALID_ACCESSES;
	if ( not exists $valid_accesses{$access} ) {
	    croak qq(Invalid File access "$access");
	}
	$self->{ACCESS} = $access;
    }

    return $self->{ACCESS};
}

sub File {
    my $self		= shift;
    my $glob		= shift;

    if ( not defined $glob ) {
	croak qq(Matching glob file pattern required);
    }

    my $match = Section::glob2regex( $glob );
    return $self->Match( $match );
}

sub Case {
    my $self		= shift;
    my $case		= shift;

    if ( defined $case ) {
	$case = lc $case;
	my %valid_cases;
	map { $valid_cases{lc $_} = 1 } +VALID_CASES;
	if ( not exists $valid_cases{$case} ) {
	    croak qq(Invalid case "$case" passed to method);
	}
	$self->{CASE} = $case;
    }
    return $self->{CASE};
}

sub Users {
    my $self		= shift;
    my $users		= shift;

    if ( defined $users ) {
	my @users = split /[\s,]+/, $users;
	$self->{USERS} = \@users;
    }

    my @users = @{ $self->{USERS} };
    return wantarray ? @users : \@users;
}

sub Verify_parameters {
    my $self =		shift;
    my $required =	\@{ +REQ_PARAMETERS };

    return $self->SUPER::Verify_parameters($required);
}
#
# END: CLASS Section::Group
########################################################################

########################################################################
# CLASS: Section::Property
#
package Section::Property;
use Carp;
use base qw(Section);

use constant REQ_PARAMETERS	=> qw(Match Property Value Type);
use constant VALID_TYPES	=> qw(string number regex);
use constant VALID_CASES	=> qw(match ignore);

sub Match {
    my $self		= shift;
    my $match		= shift;

    if ( defined $match ) {
	$self->{MATCH} = $match;
    }
    return $self->{MATCH};
}

sub File {
    my $self		= shift;
    my $glob		= shift;

    if ( not defined $glob ) {
	croak qq(Method is only for setting not fetching);
    }

    my $match = Section::glob2regex($glob);
    return $self->Match( $match );
}

sub Case {
    my $self		= shift;
    my $case		= shift;

    if ( defined $case ) {
	my %valid_cases;
	my $case = lc $case;
	map { $valid_cases{lc $_} = 1 } @{[VALID_CASES]};
	if ( not exists $valid_cases{$case} ) {
	    croak qq(Invalid case "$case");
	}
	$self->{CASE} = $case;
    }
    return $self->{CASE};
}

sub Property {
    my $self		= shift;
    my $property	= shift;

    if ( defined $property ) {
	$self->{PROPERTY} = $property;
    }
    return $self->{PROPERTY};
}

sub Value {
    my $self		= shift;
    my $value		= shift;

    if ( defined $value ) { 
	$self->{VALUE} = $value;
    }
    return $self->{VALUE};
}

sub Type {
    my $self		= shift;
    my $type		= shift;

    if ( defined $type ) {
	my $type = lc $type;
	my %valid_types;
	map { $valid_types{lc $_} = 1 } +VALID_TYPES;
	if ( not exists $valid_types{$type} ) {
	    croak qq(Invalid type of "$type" Property type passed);
	}
	$self->{TYPE} = $type;
    }
    return $self->{TYPE};
}

sub Verify_parameters {
    my $self =		shift;
    my $required =	\@{ +REQ_PARAMETERS };

    return $self->SUPER::Verify_parameters($required);
}
#
# END: Class: Section::Property
########################################################################

########################################################################
# CLASS: Section::Revprop
#
package Section::Revprop;
use Carp;
use base qw(Section);

use constant REQ_PARAMETERS	=> qw(Property Value Type);
use constant VALID_TYPES	=> qw(string number regex);
use constant VALID_CASES	=> qw(match ignore);

sub Case {
    my $self		= shift;
    my $case		= shift;

    if ( defined $case ) {
	my %valid_cases;
	my $case = lc $case;
	map { $valid_cases{lc $_} = 1 } @{[VALID_CASES]};
	if ( not exists $valid_cases{$case} ) {
	    croak qq(Invalid case "$case");
	}
	$self->{CASE} = $case;
    }
    return $self->{CASE};
}

sub Property {
    my $self		= shift;
    my $property	= shift;

    if ( defined $property ) {
	$self->{PROPERTY} = $property;
    }
    return $self->{PROPERTY};
}

sub Value {
    my $self		= shift;
    my $value		= shift;

    if ( defined $value ) { 
	$self->{VALUE} = $value;
    }
    return $self->{VALUE};
}

sub Type {
    my $self		= shift;
    my $type		= shift;

    if ( defined $type ) {
	my $type = lc $type;
	my %valid_types;
	map { $valid_types{lc $_} = 1 } +VALID_TYPES;
	if ( not exists $valid_types{$type} ) {
	    croak qq(Invalid type of "$type" Property type passed);
	}
	$self->{TYPE} = $type;
    }
    return $self->{TYPE};
}

sub Verify_parameters {
    my $self =		shift;
    my $required =	\@{ +REQ_PARAMETERS };

    return $self->SUPER::Verify_parameters($required);
}
#
# END: Class: Section::Revprop
########################################################################

########################################################################
# Class: Section::Ban
# 
package Section::Ban;
use base qw(Section);

use Carp;

use constant REQ_PARAMETERS	=> qw(Match);
use constant VALID_CASES	=> qw(match ignore);

sub File {
    my $self		= shift;
    my $glob		= shift;

    my $match = Section::glob2regex( $glob );
    $self->Match( $match );
}

sub Match {
    my $self		= shift;
    my $match		= shift;

    if ( defined $match ) {
	$self->{MATCH} = $match;
    }
    return $self->{MATCH};
}

sub Case {
    my $self		= shift;
    my $case		= shift;

    if ( defined $case ) {
	$case = lc $case;
	my %valid_cases;
	map { $valid_cases{lc $_} = 1 } +VALID_CASES;
	if ( not exists $valid_cases{$case} ) {
	    croak qq(Invalid case "$case" passed to method);
	}
	$self->{CASE} = $case;
    }
    return $self->{CASE};
}

sub Verify_parameters {
    my $self =		shift;
    my $required =	\@{ +REQ_PARAMETERS };

    return $self->SUPER::Verify_parameters($required);
}
#
# END: Class Section::Ban
########################################################################

########################################################################
# Class Section::Ldap
#
package Section::Ldap;
use Carp;
use base qw(Section);

use constant REQ_PARAMETERS	=> qw(ldap);

use constant {
    DEFAULT_NAME_ATTR	=> "sAMAccountName",
    DEFAULT_GROUP_ATTR	=> "memberOf",
    DEFAULT_TIMEOUT	=> 5,
};

BEGIN {
    eval { require Net::LDAP; };
    our $ldap_available = 1 if not $@;
}
our $ldap_available;

sub Ldap {
    my $self		= shift;

    if ( not $self->Description ) {
	croak qq(Missing description which contains the LDAP server list);
    }

    my @ldaps = split /[\s,]+/, $self->Description;	
    return wantarray ? @ldaps : \@ldaps;
}

sub Username_attr {
    my $self		= shift;
    my $username_attr	= shift;

    if ( defined $username_attr ) {
	$self->{USER_NAME_ATTR} = $username_attr;
    }

    if ( not exists $self->{USER_NAME_ATTR} ) {
	$self->{USER_NAME_ATTR} = DEFAULT_NAME_ATTR;
    }
    return $self->{LDAP_ACCT_ATTR};
}

sub Group_attr {
    my $self		= shift;
    my $group_attr	= shift;

    if ( defined $group_attr ) {
	$self->{GROUP_ATTR} = $group_attr;
    }
    if ( not exists $self->{GROUP_ATTR} ) {
	$self->{GROUP_ATTR} = DEFAULT_GROUP_ATTR;
    }
    return $self->{GROUP_ATTR};
}

sub User_dn {
    my $self		= shift;
    my $user_dn		= shift;

    if ( defined $user_dn ) {
	$self->{USER_DN} = $user_dn;
    }
    return $self->{USER_DN};
}

sub Password {
    my $self		= shift;
    my $password	= shift;

    if ( defined $password ) {
	$self->{PASSWORD} = $password;
    }
    return $self->{PASSWORD};
}

sub Search_base {
    my $self		= shift;
    my $search_base	= shift;

    if ( defined $search_base ) {
	$self->{SEARCH_BASE} = $search_base;
    }
    return $self->{SEARCH_BASE};
}

sub Timeout {
    my $self		= shift;
    my $timeout		= shift;

    if ( defined $timeout ) {
	if ( $timeout =~ /^\d+$/ ) {
	    croak qq(Timeout value for ldap server must be an integer);
	}
	$self->{TIMEOUT} = $timeout;
    }

    if ( not exists $self->{TIMEOUT} ) {
	$self->{TIMEOUT} = DEFAULT_TIMEOUT;
    }
    return $self->{TIMEOUT};
}

sub Ldap_Groups {
    my $self		= shift;
    my $user		= shift;

    my $ldap_servers	= $self->Ldap;
    my $user_dn		= $self->User_dn;
    my $password	= $self->Password;
    my $search_base	= $self->Search_base;
    my $timeout		= $self->Timeout;

    my $username_attr	= $self->Username_attr;
    my $group_attr	= $self->Group_attr;

    if ( not defined $user ) {
	croak qq(Need to pass in a user name);
    }

    #
    # Create LDAP Object
    #
    my $ldap = Net::LDAP->new( $ldap_servers, timeout => $timeout, onerror => "die" );
    if ( not defined $ldap ) {
	croak qq(Could not connect to LDAP servers:)
	    . join ", ", @{ $ldap } . qq( Timeout = $timeout );
    }
    #
    # Try a bind
    #
    eval {
	if ( $user_dn and $password ) {
	    $ldap->bind( $user_dn, password => $password );
	}
	elsif ( $user_dn and not $password ) {
	    $ldap->bind( $user_dn );
	}
	else {
	    $ldap->bind;
	}
    };
    if ( $@ ) {
	no warnings qw(uninitialized);
	croak qq(Could not "bind" to LDAP server.) 
	    . qq( User DN: "$user_dn" Password: "$password");
    }

    #
    # Search
    #

    my $search;
    eval {
	if ( $search_base ) {
	    $search = $ldap->search(
		basename => $search_base,
		filter => "($username_attr=$user)",
	    );
	}
	else {
	    $search = $ldap->search(
		filter => "($username_attr=$user)",
	    );
	}
    };
    if ( $@ ) {
	croak qq(Search of LDAP tree failed);
    }

    #
    # Get the Entry
    #
    my $entry = $search->pop_entry;	#Should only return a single entry
    if ( undef $entry ) {
	croak qq(Could not locate "$user" with attribute "$username_attr".);
    }

    #
    # Get the attribute of that entry
    #

    my @groups;
    for my $group ( $entry->get_value( $group_attr ) ) {
	$group =~ s/cn=(.+?),.*/\L$1\U/i;  	#Just the "CN" value
	push @groups, $group;
    }
    return wantarray ? @groups : \@groups;
}
#
########################################################################

########################################################################
# POD DOCUMENTATION
#
=pod

=head1 NAME

pre-commit-kitchensink-hook.pl

=head1 SYNOPSIS

    pre-commit-kitchen-sink-hook.pl [-file <ctrlFile>] \\
	[-fileloc <cntrlFile>] (-r<revision>|-t<transaction>) \\
	[-parse] [-svnlook <svnlookCmd>] [<repository>]

    pre-commit-kitchen-sink-hook.pl -help

    pre-commit-kitchen-sink-hook.pl -options

=head1 DESCRIPTION

This is a Subversion pre-commit hook that can check for several issues
at once:

=over 2

=item *

This hook can verify that a particular user has permission to change a
file. The file can be specified as either a I<glob> or I<regex> format.
Even better, you can also specify an I<ADD-ONLY> setting that allows you
to create tags via an C<svn copy>, but won't allow you to modify the
files in that directory. This protects tags from being modified by a
user.

=item *

This hook can verify that a particular property has a particular value
and has been set on a particular file. You can specify the files via
I<regex> or I<glob> format, and you can specity the value of the
property either via a I<string>, I<regex>, or I<numeric> value.

=item *

This hook can prevent the user from adding files with banned names. For
example, in Windows you cannot have a file that starts with  C<aux> or
C<prn> or C<con>. You also can't have file names that have C<:>, C<^>,
and several other types of characters in them. You may also want to ban
file names that have spaces in them since these tend to cause problems
with some utilities. This only affects newly added or renamed files, and
not current files.

=item *

This hook can also verify that particular revision properties are set.
However, this only works on Subversion release 1.5 or greater. But,
since Subversion release 1.4 is no longer supported, you really
shouldn't be using releases older than 1.5 anyway.

=back

This hook works through a control file that is in standard Windows
Inifile format (described below). This allows you to set permissions and
other changes without having to modify this program itself.

=head1 OPTIONS

=head2 Control File Definition

The I<Control File> controls the way this hook operates. It can control
the permissions you're granting to various users, your group
definitions, what names are not allowed in your repository, and the
properties associated with the file and revision.

There are two places where the control file can be stored. The first is
inside the Subversion repository server as a physical text file. This
keeps the control file away from prying eyes. Unfortunately, it means
that you must have login access to the repository server in order to
maintain the file.

The other place is inside the repository itself. This makes it easy to
maintain. Plus, since it's in a Subversion repository, you'll see who
changed this file, when, and why. That can be nice for auditing.
Unfortunately, this file will be visible to everyone. If you have an
LDAP password in that file, you'll be exposing that password to all of
your users.

You are allowed to use either a physcial control file, a control file
stored in the repository, or both. You must have at least one or the
other defined.

Format of the control file is discussed below. See L<CONTROL FILE
LAYOUT>

=over 10

=item -file

The location of the physical text control file stored on the Subversion
repository server. Normally, this is kept in the F<hooks> directory
under the Subversion repository directory.

=item -fileloc

The location fo the control file inside the Subversion repository. This
should use the C<svnlook> format. For exmaple, if you have a directory
called F<control> under the root of your repository, and inside, your
control file is called C<control.ini>, the value of this parameter would
be F</control/control.ini>.

=back

=head2 Other Options

=over 10

=item -r

The Subversion repository revision. Normally, this is only used for
testing purposes since you really want the transaction number of the
commit and not the revision number. Good for testing. This parameter
cannot be used at the same time as the C<-t> parameter.

=item -t

The Subversion repository Transaction Number. This is passed to the
scrip pre-commit found in the Repository's hook directory as a
parameter. You need to modify the pre-commit script to pass the
transaction number to this script.

=item -svnlook

This is the full path to the svnlook command. The full path is needed
because for security reasons, the C<PATH> environment variable is empty
when the hook is executed. Default is /usr/bin/svnlook.

=item -parse

Used mainly for debugging. This will dump out the entire configuration file
structure, so you can verify your work. It will also test the control file
and let you know if there are any errors.

=item -help

Prints a helpful message showing the different parameters used in
running this pre-commit hook script.

=item -options

Prints a helpful message showing a detailed explanation of  the
different parameters used in running this pre-commit hook script.

=item <repository>

The location of the Subversion repository's physical directory. Default
is the parent directory.

=back

=head1 CONTROL FILE LAYOUT

The hook is controlled by a user defined control file. The control is in
Windows' IniFile layout. This layout consists of I<Comments>, I<Section
Headings>, and I<Parameter Lines>.

=head2 Comments

Comment lines begin with either a C<#>, or a C<;> or a C<'>. Blank lines
are also ignored. All other lines must either be a Parameter Line or a
Section Heading.

=head2 Basic Layout

The basic layout is a Section Heading followed by a bunch of Parameter
Lines.

Section headings are enclosed in square brackets. The first word
in a section heading is the type of section it is (Group, File,
Property, Revprop, or Ban). The rest is a description of that section
heading. For example:

    [File Users may not modify a tag.]

In the above example, the section is I<File> and the description is
I<Users may not modify a tag.>. 

Unlike in L<Config/IniFile>, the descriptions don't have to be unique.
However, the descriptions are used in user error messages, so be sure
to put in a good description that is user friendly. For example:

    [File Only approved users may modify the Control File]

is a better section heading than:

    [File Read-only on Control.properties]

Under each section is a series of Parameter lines that apply to that section.

Parameter Lines are in the form of

    <Key> = <Value>

where I<Key> is the parameter key, and I<Value> is the value for that
parameter. Notice that the two are separated by an equal sign. Spaces
around the equal sign are optional, and the I<Value> is the entire line
including spaces on the end of the line, so be careful.

The layouts of the various sections and their permitted parameters are
explained below. Note that section type names and parameter keys are
case insensitive.

=head3 Group

This is used to define user groups which can be used to define file
permissions. This makes it easier to keep track of file permissions as
people move from project to project. You only have to change the group
definition.

The section layout is thus:

    [GROUP <GroupName>]
    users = <ListOfUsers>

The C<GroupName> is the name of the group. Group names should be
composed of just letters, numbers, and underscores, and should contain
no white space. Group names are case insensitive.

User names in this hook substitute an underscore for a space and ignore case
For example, if the user signs into Subversion as I<john doe>, their user name
will become I<JOHN_DOE>. User names cannot start with an I<at sign> (@).

The C<ListOfUsers> is either a whitespace or comma separated list of user
names. This list can also contain the names of other groups. However, the
groups are calculated from the top of the control file to the bottom, so
if group "A" is contained inside group "B", you must define group "A" before
you define group "B".

    [GROUP developers]
    users = larry, moe, curly

    [group admins]
    users = tom, dick, harry

    [group foo]
    users = @developers, @admins, @bar, alice

    [group bar]
    users = bob, ted, carol

In the above example, everyone in group I<DEVELOPERS> and group I<ADMINS>
is in group I<FOO>. However, members of group I<BAR> won't be included.

=head3 File

A file Section Heading starts with the word C<file> and an explanation
of that section. It then consists of the following parameters:

=over 7

=item match

A Perl style expanded regular expression matching the files that are
affected by this permission definition. Note this cannot be used with
the C<file> parameter.

If the C<match> string contains the text E<lt>USERE<gt>, this text
will be substituted by the name of the user from the C<svnlook author>
command. This is done to allow you to create special user directories or
files that only that user can modify. For example:

    [FILE Users can only modify their own watchfiles]
    match = ^/watchfiles/.*
    access = read-only
    users = @ALL

    [FILE Allow user to edit their own watchfiles]
    match = ^/watchfiles/<USER>\.cfg$
    access = read-write
    users = @ALL

The above will prevent users from modifying each other watch files, but
will allow them to modify their own watch files.

B<Word o' Warning>: This script normalizes user ID to all caps. This
means that if the user name is I<bob>, it will become I<BOB>. Thus,
I<< <USER> >> also becomes F<BOB>.


=item file

An Ant style  globbing expression matching the files that are affected
by this permission definition. This cannot be used with the C<match>
parameter.

Regular expressions are much more flexible, but most people are not too
familiar with them. In a file glob expression, an asterisk (*)
represents any number of characters inside of a directory. Double
asterisk (**) are used to represent any number of directory levels. A
single quesion mark (?) represents any character. All glob expressions
are anchored to the front of the line and the back of the line.

Therefore:

    file = *.jpg

does not mean any file that end with C<jpg>, but only files in the root
of the repository that end with C<jpg>. To mean all files, you need to
unanchor the glob expression as thus:

    file = **/*.jpg

Notice too that directory names will end with a final slash which is
a great way to distinguish between a file being added or deleted
and a directory being added or deleted. For example:

    file = /tags/*/

will refer only to directories that are subdirectories directly under the
tags directory, and not to files. You'll see this is a great way to protect
your tagged versions from being modified when L<access> is discussed below.

If the C<file> string contains the text C<E<lt>USERE<gt>>, this text
will be substituted by the name of the user from the C<svnlook author>
command. This is done to allow you to create special user directories or
files that only that user can modify. For example:

    [FILE Users can only modify their own watchfiles]
    file = /watchfiles/**
    access = read-only
    users = @ALL

    [FILE Allow user to edit their own watchfiles]
    file = /watchfiles/<USER>.cfg
    access = read-write
    users = @ALL

The above will prevent users from modifying each other watch files, but
will allow them to modify their own watch files.

=item users

A list of all users who are affected by this type of access. Groups can
be used in a user list if preceeded by an I<at sign> (@). There is one
special group called C<@ALL> that represents all users.

=item access

The access permission on that file. Notice that there is no permission
for preventing a user from seeing the contents of the file, only for
changing the file. This is because the trigger is on the C<commit>
and not on C<checkout>. If you need to prevent people from seeing
the file, you must do this with your repository access.

Access is determined in a top down fashion in the control file. The first
entry might take a particular user's ability to commit changes to a particular
file, but a section further down might allow that same user the ability
to commit changes to that same file. While the third might remove it again.

Access is granted or denied by the B<last> matching access grant.

=over 10

=item read-write

Files marked as C<read-write> means that the user may commit changes to
the file. They can add a new file or directory by that name, delete it, or
modify it.

=item read-only

Files marked as C<read-only> means that the user cannot commit changes to
that file. The user is not allowed to create, delete, or modify this
file.

=item no-delete

Files marked as C<no-delete> allow the user to modify and even create the
file, but not delete the file. This is good for a file that needs to be
modified, but you don't want to be removed.

=item no-add

Files marked as C<no-add> allow the user to modify the file if it already
exists, and are allowed to delete a file if it already exists, but they
are not allowed to add a new file to the repository. This is combined
with the L<no-delete> option above to allow people to modify files, but
not to add new files or delete old ones from the repository.

=item add-only

This is a special access permission that will allow a user to add, but not
modify a file with that matching pattern or regex. This is mainly used to 
ensure that tags may be created but not modified. For example, if you have
a C</tags> directory, you can do this:

    [FILE Users cannot modify any tags]
    file = /tags/**
    access = read-only
    user = @ALL

    [FILE Users can add tags to the tag directory]
    file = /tags/*/
    access = add-only
    user = @ALL

The first L<File> section removes the user's ability to make any changes in
the C</tags> directory. The second L<File> section allows users to only add
directories directly under the C</tags> directory. Thus, a user can do
something like this:

    $ svn cp svn://localhost/trunk svn://localhost/tags/V-1.3

to tag version 1.3 of the source, but then can't modify, add, or delete any
files under the C</tags/V-1.3> directory. Also, users cannot do something
like this:

    $ svn cp svn://localhost/trunk svn://localhost/tags/V-1.3/BOGUS

because the ability to copy a directory is only allowed in the C</tags/>
directory and no subdirectory.

Nor, can a user do this:

    $ touch tags/foo.txt
    $ svn add tags/foo.txt
    $ svn commit -m"Adding a file to the /tags directory"

Since only directories can be added to the C</tags> directory.

=back

=item case

This is an optional parameter and its only valid value is I<ignore>. This
allows you to ignore case when looking at file names. For example:

    [file Bob can edit our batch files]
    file = **/*.bat
    access = read-write
    users = bob
    case = ignore

This will match every Batch file with a suffix of I<*.bat> or I<*.BAT> or
even I<*.Bat> and I<*.BaT>.

=back

=head3 Property

This section allows you to set what properties and what those property
values must be on a particular set of files. The section heading looks
like this:

    [property <purpose>]

Where C<purpose> is the purpose of that property. This is used as an
error message if a file fails to have a required property or that
property is set to the wrong value. The following parameters are used:

=over 7

=item match

A Perl style expanded regular expression matching the files that are
affected by this property. Note this cannot be used with the C<file>
parameter.

=item file

A glob type expression matching the files that are affected by this
property. Note this cannot be used with the C<match> parameter.

=item case

An optional parameter and the only permitted value is I<ignore>. This
means to ignore the case of file names (not property values! They're
still case sensitive)

=item property

The name of the property that should be on this file. 

=item value

The value the property should have. Note that this can be either a
string, a number of a regular expression that the value should match.
This is determined by the I<type> parameter.

=item type

The type of value that the I<value> parameter actually contains. This
can be C<string>, C<number>, or C<regex>.

=back

=head3 Revprop

This section allows you to set what revision properties and what
those property values must be when committing a revision.

    [revprop <purpose>]

Where C<purpose> is the purpose of that property. This is used as an
error message if the revision fails to have a required revision property
or that property is set to the wrong value.

The Revision property of C<svn:log> is a special revision property
that all Subversion clients and server versions can use. This is
set by the C<-m> parameter in the C<svn commit> command. This can
be used to verify that the commit log message is in the correct format.

Here is an example:

    [revprop Users must have at least 10 characters of a commit message]
    property = svn:log
    value = ^.{10,}
    type = REGEX

The above requires a user to create an at least 10 character commit
message when committing a change. This will prevent a user from leaving
a null message. You can get even more complex and imaginative:

    [revprop Users must include a Jira ticket number with a commit, or NONE]
    property = svn:log
    value = ^(NONE)|(([A-Z]{3,4}-\d+(,\s+)?)+):.{10,}
    type = REGEX

Imagine you have a ticketing system where ticket numbers start with a three
or four capital letter issue type, followed by a dash, followed by an
issue number (much like Jira). The above will require a user to list
one or more comma separated issue IDs, followed by a colon and a space. If
there is no issue ID, the user can use the word "NONE". This has to
be followed by at least a ten character description. The following
would be valid commit comments:

    NONE: Fixed the indentation of a few files.
    FOO-123: Added a new format to match the specs
    BAR-334, BAZ-349: Fixed the display bug

While the following wouldn't be allowed:

    Fixed stuff
    AAAA
    FOO-123: SSDd

If both the client and server run a release of Subversion 1.5 or
greater, you can use other revision properties on a commit.

Revision properties are set with the C<--with-revprop> on the
C<svn commit> command. Revision properties other than C<svn:log>
can only be used when the Subversion client and server revisions
are 1.5 or newer.

B<WARNING:> Users with a Subversion client older than 1.5
won't be allowed to commit changes if revision properties other
than C<svn:log> are required.

=over 7

=item property

The name of the revision property that should be set in this revision.

=item value

The value the revprop should have. Note that this can be either a
string, a number of a regular expression that the value should match.
This is determined by the I<type> parameter.

=item type

The type of value that the I<value> parameter actually contains. This
can be C<string>, C<number>, or C<regex>.

=back

=head3 Ban

    This section allows you to ban certain file names when you add a new
    file. For example, in Unix, a file can be called C<aux.java>, but
    such a name would be illegal in Windows. 

    The section heading looks like this:

    [ban <description>]

    where E<lt>descriptionE<gt> is the description of that ban. This is
    returned to the user when a banned name is detected.

=over 7

=item match

A Perl style regular expression matching the banned names. Note this
cannot be used with the C<file> parameter.

=item file

An Ant style globbing expression that matches the banned names. Note
this cannot be used with the C<item> parameter.

=item case

This is an optional parameter. If set to I<ignore>, it will ignore the
case in file names.

=back

=head3 Ldap

This section defines an LDAP server for the purposes of pulling of LDAP
groups to use in this hook. For example, if you have a Windows Active
Directory server, you could use your Windows groups to put users into
groups for this particular hook.

Due to the complexities of the LDAP query and the wide variety used by
various groups, it is somewhat necessary to play loose and fast with the
way attributes work.

The section heading will look like this:

    [ldap <ldapURI or server>]

Where the name of the LDAP server (or full URI can be contained in the
section name.

=over 7

=item ldap:xxxxx

This allows you to further define how to do ldap binding. The "xxxx" is
the option in the Net::LDAP constructor. For example, C<ldap:scheme> will
be the I<scheme> option in the Net::LDAP constructor. The most common ones
are:

=over 2

=item * ldap:password

The password for the ldap server

=item * ldap:scheme

This could be F<ldap> or F<ldaps>

=item * ldap:port

The port number for LDAP.

=back

=item bind

The I<Distinguished Name> used by the LDAP server for I<binding>
(logging in) to the ldap server. If not given, anonymous binding will be
done.

=item bind:xxxx

This is an option used in the F<bind> method in the L<Net::LDAP> class.
The most common ones are:

=over 2

=item * bind:password

The password for the Distinguish name.

=back

=item filter

This is the attribute you are filtering on via the Ldap name of the
user. In Windows Active Directory, this is usually something like
C<sAMAccountName>.

This is used by the I<search> method of the Net::LDAP module. For
example, let's say that you've filtered on C<sAMAccountName> for Ldap
user C<johnsmith>. The call to the Net::LDAP search method will
look something like this:

    my $search = $ldap->search(filter => "sAMAccountName=johnsmith");

=item search:xxxxxx

Other attributes to use for the search method. Common ones are

=over 2

=item * search:attrs

A list of attributes to return.

=back

=item groupAttr

The attribute in the member LDAP record that contains the group names.
    It is normally C<memberOF> in Window's ActiveDirectory.

=item regex

When LDAP returns a group, it returns the full I<Common Name> for that
group. Normally, you only want the first part of the name. For example,
the LDAP I<CN> might be:

    CN=AppTeam,OU=Groups,OU=Accounts,DC=mycorp,DC=com

but you want just the I<AppTeam> as the group name. You can use this
to pinpoint the group name in the expression. You use parentheses to
mark the place in the regular expression where you will find the
name of the group. For example, the following will pinpoint the
name of the group (I<AppTeam>) in the above expression:

	regex = ^[^=]+=([^,]+)

Note that the quoting slashes are not around the regular expression.
B<DO NOT INCLUDE THEM!>. Otherwise, your group anames will be messed up.

In fact, the above regular expression is pretty much the stanadard one
that you will use.

Note that the group name will be I<normalized> which means that it will
be uppercased and blanks will be replaced by underscores.

=back 

=head4 LDAP Example

Here's an example of what an LDAP section might look like. It pretty
much follows what someone who uses Windows Active Directory for
corporate access. 

	[ldap ldap://ldapserver.mycorp.com:389]
	bind = CN=subversion,OU=Users,OU=Accounts,DC=mycorp,DC=com
	bind:password = Sw0rdfi$h
	filter = sAMAccountName
	groupAttr = memberOf
	regex = ^CN=([^,]+),

=head1 AUTHOR

David Weintraub
L<mailto:david@weintraub.name>

=head1 COPYRIGHT

Copyright (c) 2010 by David Weintraub. All rights reserved. This
program is covered by the open source BMAB license.

The BMAB (Buy me a beer) license allows you to use all code for whatever
reason you want with these three caveats:

=over 4

=item 1.

If you make any modifications in the code, please consider sending them
to me, so I can put them into my code.

=item 2.

Give me attribution and credit on this program.

=item 3.

If you're in town, buy me a beer. Or, a cup of coffee which is what I'd
prefer. Or, if you're feeling really spendthrify, you can buy me lunch.
I promise to eat with my mouth closed and to use a napkin instead of my
sleeves.

=back

=cut

#
########################################################################
